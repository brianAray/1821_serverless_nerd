# Docker
- Open source platform for containerization of applications
- Containerization is a type of virtualization technology that allows developers to package and run applications in an isolated and portable environment
    - Docker works by using the underlying host OS's kernel to create isolated containers
- Docker can be run on any infrastructure that supports Docker. This includes any on-premises servers, cloud-based platforms, and hybrid environments
- Docker helps to provide a **consistent environment** for an application to run in
    - Without Docker, we would have to ensure that every server an application runs on has the same set of software and configurations, such as the same version of the programming language runtime (Node.js 14, Node.js 16, Node.js 18, etc..)
        - Example: 2 Node.js apps (one requires Node.js 14, another one requires Node.js 18). Without Docker, we cannot run both applications at the same time. We would need to uninstall Node.js 14, install 18, and vice versa if we want to switch between the apps we're running
    - With Docker, we can be confident that no matter what server an application is ran on, it will behave the same way predictably
        - Node.js 14 app running in one container, Node.js 18 app running in another container, on the same machine
        - I do not even need to install Node.js to the computer itself, because the containers will each contain the necessary Node.js runtime

## Docker v. Virtual Machines
- Docker containers share the host operating system's kernel and resources, while VMs run a complete operating system and have their own allocated resources
- Docker containers are more lightweight than VMs, since they don't require an entire OS within the container. Each VM runs its own OS, which adds extra bloat
- Containers can be easily created, modified, and deleted, while VMs can be more difficult to modify and manage, since each VM includes a complete OS and other dependencies

## Docker Architecture
Docker is based around a "client-server" model. The Docker CLI (command-line interface) is the client that talks to the Docker Daemon

- Docker CLI: command-line interface that allows you to interact with the Docker Daemon by typing commands
- Docker Daemon: core component of Docker that is responsible for building, running, and managing Docker containers. It communicates with the host OS kernel and other Docker components
- Docker Registry: repositories for storing or distributing Docker images. You can use public or private registries for storing images and pulling images.
    - DockerHub is a public registry that Docker is configured by default to pull images from

## How Docker Works
1. Image Creation (or use an image that already exists): a Docker image is created by specifying instructions in a Dockerfile. The Dockerfile contains commands that specify what base image to use, commands to install dependencies, and any configuration that needs to be performed. When the Dockerfile is executed, an image is built on top of a base image with the application
2. Container Creation: A container can be created from a Docker image. The container is separated into its own isolated environment on the system, having its own filesystem, network, and process space. The host machine's operating system's kernel is used to provide isolation for each container
3. Container execution: When a container is executed, the application runs within the container's isolated environment. The container has access to resources it needs to run, such as a file system, network, and process space, but is isolated from the host OS and other containers

Summary: Docker images -> Used to create Docker containers -> Run Docker containers

## Docker Commands
- `docker ps`: Used to list containers that are currently running
- `docker images`: Used to list images that are locally available on the host
- `docker build`: Used to build a Docker image from a Dockerfile
- `docker push`: Used to push an image to a Docker registry
- `docker pull`: Used to pull an image from a Docker registry
- `docker create`: Used to create a container from an image, without starting the container
- `docker start`: Used to start a container that is not running
- `docker run`: Used to create AND start a container from an image
- `docker stop`: Used to stop a running container
- `docker rm`: Used to remove a container
- `docker rmi`: Used to remove an image
- `docker inspect`: Used to view detailed info about a container or image
- `docker logs`: Used to view logs generated by a container

## Dockerfile
A Dockerfile contains instructions for building a Docker image. It is a file that contains a series of commands and arguments. Each command specifies a step in the build process, which the Docker daemon uses to build the image. A Dockerfile might contain commands to
- Specify the base image to use
- Copy files from host to Docker image
- Install packages and dependencies
- Set the default command to execute when a container is started from the image

## Dockerfile Commands/Keywords
- `FROM`: Specifies the base image to use as a starting point for the build
    - Ex. Nginx image or Node image
- `WORKDIR`: Sets the working directory for the subsequent instructions in the Dockerfile
- `COPY`: Copy files or directories from the host system into the Docker image
    - For example, you may copy all of the application files into the Docker image
- `RUN`: Executes a command. Can be used to install dependencies (`npm install`), configurations, etc.
- `ENV`: Set environment variables in the Docker image
- `EXPOSE`: Specify the port that the container uses
    - Ex. if your node app is using port 8080, then use EXPOSE 8080
- `CMD`: Specifies the default command to run when a container is started from the image
- `ENTRYPOINT`: Specifies the command to run when the container starts

CMD v. ENTRYPOINT
- CMD can be overwritten when starting the container by specifying additional command line arguments
- ENTRYPOINT cannot be overwritten. Any additional command line arguments will not be assumed to be a command, but rather arguments that are appended to the ENTRYPOINT command

## Port Mapping
When creating a container, we need to specify a port mapping so that external traffic can make its way into the container. The way it works for Docker is that each container has its own isolated network, so by default, no external traffic can reach the container.

If we use the `docker run` command, for example, then `docker run -p 4000:8080 <image ID or image name>` will create AND start a container that has port 4000 of the host mapped to port 8080 of the container. Any external traffic must send data to port 4000, which will then be reached by the container

## More on Docker Registries
A Docker container registry is a centralized repository for storing and distributing Docker images. Here are some key points regarding registries:
1. Public and private registries: A docker repository can either be a public or private one. Public repositories are available to anyone and can be used to store and distribute public images. Anybody can pull an image from a public repository. Private repositories, on the other hand, are only accessible to authorized users.
2. Security: Docker registries, in particular private repositories, have access control features as well as encryption. This helps to ensure that images are secure and only accessible to authorized users
3. Image Management: Images can be managed through tagging, which allows us to have multiple different versions of an image

Image Naming Convention
- `<docker account identifier>/<image name>:version`
    - version: either be `latest` or some sort of number, such as `1.0`

Pull an image: `docker pull <entire image name>`
- if you leave off `:<version>` at the end, it will implicitly pull the `:latest` version

Push an image: `docker push <entire image name>`
- Need to be logged in to push
- `docker login`
    - Specify username + password (ex. DockerHub)
    - Use AWS CLI: `aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin <account identifier>` (for AWS ECR)
        - You need the appropriate permissions for whatever is using the CLI command (ex. if running command on EC2, must have IAM Role attached to EC2 with the appropriate ECR permissions)

## AWS ECR
Amazon ECR (Elastic Container Registry) is a fully-managed Docker container registry provided by AWS. It is a secure and scalable service that makes it easy to store, manage, and deploy Docker container images
